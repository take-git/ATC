# 部分和問題の解法について
以下の問題を考える
```
部分和問題
N個の正の整数a0, a1, a2,...an-1と正の整数Wが与えられます。
a0,...an-1の中っから何個かの整数を選んで総和をWとすることができるかどうかを判定してください
```

この問題には3つの解法が存在する。
## 解法１.bit全探索によるアプローチ
まず回答となるプログラムを示す
```cpp
#include<iostream>
#include<vector>//可変長配列
#include<algorithm>//sort,二分探索,など
#include<map>//map(辞書)

using namespace std;

int main() {
    // 基本的には選ぶ、各値を選ばないの二値の問題の全探索でとく手法をまず考える >> O(N2^N)
    // 入力受け取り
    int N,W;
    cin >> N >> W;
    vector<int> a(N);
    for(int i = 0; i < N; ++i){
        cin >> a[i];
    }

    // bitは2^N通りの部分集合全体を動く
    bool exist = false;
    for(int bit = 0; bit < (1 << N); bit++){
        int sum = 0; // 部分集合に含まれる要素の和
        for(int i = 0; i < N; ++i){
            // i番目の要素a[i]が部分集合に含まれているかどうか
            if(bit & (1 << i)){ // 肝となる判定方法
                sum += a[i];
            }
        }

        // sumがWに一致するかどうか
        if (sum == W) exist = true;
    }

    if(exist) cout << "Yes" << endl;
    else cout << "No" << endl;
    return 0;
}
```

肝となるのは以下の演算だろう。
```cpp
if(bit & (1 << i)){ // 肝となる判定方法
    sum += a[i];
}
```
ここでi番目の要素を含むか含まないかを判定している。
まず問題を振り返る。a_iによって構成されるsumは合計で何通りあるだろうか？答えは2^N通り存在する。それぞれの要素に関して選ぶか、選ばないかを選択することができるためである。
解法１のアプローチでは素直に2^N個存在する全ての組み合わせを探索する。for文の中でそのループ中にその要素を含むかどうかを判定し、含まれていればsumに加算する、ということを繰り返している。

```
bit & (1 << i)
```
<<はシフト演算で、bitを左にシフトする。int型に対する&演算は両方のbitが1の時のみ結果が1になる。
## 解法２.分割統治法を用いたアプローチ
解法１は計算量としてO(N2^N)もの計算量になる。Nが小さい間はまだどうにかなるが、累乗で計算量が増えるので、すぐに限界がくる。20~25くらいまではギリギリ耐えるかもしれないが、30までいくと死ぬ。
しかし分割統治法を利用することによって計算量をO(2^N)まで落とせる。さらにメモ化することでO(NW)まで落とすことができる。まずは分割統治法によるアプローチをみてみる。


## 解法3.メモ化によるさらなる高速化
前述したようにメモ化によってこのアルゴリズムはO(NW)まで計算量が落とせる。要加筆
## まとめ